# 数据泄露检查报告

## 检查对象
- **训练运行**: run_20260113_164941
- **数据集**: TA超声图像 (0-20岁年龄限制)
- **检查时间**: 2026-01-15

## 检查方法

本次检查采用三层验证策略：

### 1. 配置层验证 (`check_data_leakage.py`)
- 读取训练配置和评估结果
- 验证数据划分方法和参数设置
- 检查测试集样本的年龄标签一致性

### 2. 统计层验证 (`check_data_leakage_deep.py`)
- 验证受试者数量的数学完整性
- 检查训练集、验证集、测试集的受试者数量之和是否等于总数
- 确认固定随机种子的使用

### 3. 代码执行层验证 (`verify_no_leakage.py`)
- **重新执行数据划分代码**，使用完全相同的参数
- 直接计算训练集、验证集、测试集的受试者ID集合交集
- 验证重新划分的结果与实际训练时完全一致

## 检查结果

### ✅ 所有检查全部通过

#### 1. 数据划分方法 ✅
- **方法**: `by_subject_id` (按受试者ID划分)
- **实现**: 使用 `sklearn.train_test_split()` 对受试者ID列表进行划分
- **保证**: 每个受试者的所有图像都在同一个集合中

#### 2. 随机种子固定 ✅
- **种子值**: 42
- **一致性**: 训练和评估使用相同种子
- **可重复性**: 重新执行划分得到完全相同的结果

#### 3. 受试者数量完整性 ✅
```
训练集受试者: 115
验证集受试者:  21
测试集受试者:  25
─────────────────
总计:         161 (完全匹配)
```

#### 4. 受试者ID无重叠 ✅
- **训练集 ∩ 验证集 = ∅** (0个重叠)
- **训练集 ∩ 测试集 = ∅** (0个重叠)
- **验证集 ∩ 测试集 = ∅** (0个重叠)

#### 5. 测试集受试者ID完全一致 ✅
重新划分的测试集受试者ID:
```
577, 665, 694, 711, 860, 880, 903, 910, 918, 995,
1018, 1021, 1026, 1072, 1111, 1257, 1275, 1366, 1383, 1413,
1462, 1786, 1810, 1820, 1838
```

实际评估的测试集受试者ID:
```
577, 665, 694, 711, 860, 880, 903, 910, 918, 995,
1018, 1021, 1026, 1072, 1111, 1257, 1275, 1366, 1383, 1413,
1462, 1786, 1810, 1820, 1838
```

**完全一致，25个受试者全部匹配**

#### 6. 年龄范围验证 ✅
- **配置范围**: 0-20岁
- **测试集实际范围**: 1.5-18.5岁
- **符合率**: 25/25 (100%)

## 数学证明

设：
- $T$ = 训练集受试者ID集合 (|T| = 115)
- $V$ = 验证集受试者ID集合 (|V| = 21)
- $S$ = 测试集受试者ID集合 (|S| = 25)
- $U$ = 全部受试者ID集合 (|U| = 161)

验证结果：
1. $T \cap V = \emptyset$ ✅
2. $T \cap S = \emptyset$ ✅
3. $V \cap S = \emptyset$ ✅
4. $T \cup V \cup S = U$ ✅
5. $|T| + |V| + |S| = |U|$ ✅ (115 + 21 + 25 = 161)

**结论**: 三个集合两两不相交且并集为全集，因此**不存在任何受试者同时出现在训练集和测试集中**。

## 代码层面保证

### 数据集划分代码 (`dataset.py`)

```python
# 第一步: 按受试者ID分层划分出测试集
train_val_subjects, test_subjects, _, _ = train_test_split(
    valid_subjects,          # 受试者ID列表
    subject_age_groups,      # 年龄组标签（用于分层）
    test_size=test_size,     # 0.15
    random_state=42,         # 固定种子
    stratify=subject_age_groups  # 按年龄分层
)

# 第二步: 从训练+验证集中划分出验证集
train_subjects, val_subjects, _, _ = train_test_split(
    train_val_subjects,
    train_val_age_groups,
    test_size=val_size,      # 0.15
    random_state=42,         # 固定种子
    stratify=train_val_age_groups
)

# 第三步: 收集每个受试者的所有图像
for sid in train_subjects:
    for img_path in subject_images[sid]:
        train_paths.append(img_path)
        train_ages.append(age_dict[sid])
# ... 验证集和测试集同理
```

**关键点**:
1. `train_test_split()` 是对**受试者ID列表**进行划分，不是对图像列表
2. 固定 `random_state=42` 确保可重复性
3. 划分后，同一受试者的**所有图像**都被添加到同一个集合

## 最终结论

### 🎉 不存在数据泄露！

**三重验证证据**:
1. ✅ 配置文件明确记录使用 `by_subject_id` 划分方法
2. ✅ 受试者数量统计满足完整性和互斥性
3. ✅ 重新执行代码验证了集合交集为空

**理论保证**:
- 使用 `sklearn.train_test_split()` 在固定种子下对受试者ID列表进行划分
- 数学上保证每个受试者ID只出现在一个集合中
- 因此同一受试者的图像不可能同时出现在训练集和测试集

**实践验证**:
- 测试集包含25个独立受试者的79张图像
- 每个受试者平均3.16张图像
- 所有同一受试者的样本年龄标签完全一致
- 重新划分得到的测试集受试者ID与实际评估完全匹配

## 附加说明

### 为什么图像目录有1021个受试者，而只用了161个？

这是**年龄范围限制**的结果：
- 原始数据集包含所有年龄段的受试者 (1021个)
- 本次训练限制为 **0-20岁** (配置中 `age_range: "0-20.0"`)
- 过滤后只保留161个符合年龄范围的受试者
- 这161个受试者被完整地划分到训练/验证/测试集，无遗漏

### 数据划分比例

- 训练集: 71.4% (115/161受试者, 350/492图像)
- 验证集: 13.0% (21/161受试者, 63/492图像)
- 测试集: 15.5% (25/161受试者, 79/492图像)

比例略有差异是因为：
1. 首先按 15% 划分测试集
2. 然后从剩余85%中按 15% 划分验证集 (0.85×0.15=12.75%)
3. 训练集占剩余部分 (85%-12.75%=72.25%)
4. 使用年龄分层抽样，实际比例会轻微调整以保证年龄分布平衡

---

**报告生成时间**: 2026-01-15  
**验证脚本**:
- `check_data_leakage.py` - 基础检查
- `check_data_leakage_deep.py` - 深度检查
- `verify_no_leakage.py` - 代码执行验证
